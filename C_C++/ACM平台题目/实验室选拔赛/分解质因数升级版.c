#include<stdio.h>
#include<math.h>

int main(void)
{
    int a[168] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,
                    83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,
                    173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,
                    263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,
                    359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,
                    457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,
                    569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,
                    659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,
                    769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,
                    881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,
                    997};
    int n,k,i,j,m;
    k = 1;
    while (scanf("%d",&n)!=EOF)
    {
        int b[168]={0};
        for (i = 2; i <= n; i++)
        {
            m = i;
            for (j = 0; a[j] <= i; j++)
                if (m%a[j]==0)
                {
                    b[j]++;
                    m /= a[j];
                    j = -1;
                }
        }
        printf("Case %d:\n",k++);
        for (i = 0; a[i] <= n; i++)
        {
            if (b[i] > 1)
                printf(i?"*%d^%d":"%d^%d",a[i],b[i]);
            else if (b[i]==1)
                printf(i?"*%d":"%d",a[i]);
        }
        printf("\n");
    }
    return 0;
}
/*
scription

曾经做过的n的分解质因数AC的很爽吧！！！，但是今天刀姐不高兴了，为什么呢？找来小学弟（刀姐不告诉其他人啊）才问清楚原因，原来是刀姐曾经木有AC的分解质因数被AC了，于是乎很不爽，现在刀姐下了苦功夫，也玩出了花样：
问题描述：
N!分解质数
Input

输入数据有多组，每组数据包含一个整数n(2<=n<=1000)，将n!分解质因数

Output

Case i:
接下来是分解的结果
Sample Input

5
10
Sample Output

Case 1:
2^3*3*5
Case 2:
2^8*3^4*5^2*7
*/
